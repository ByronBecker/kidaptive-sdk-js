'use strict';
import TestConstants from './test-constants';
import TestUtils from '../test-utils';
import Constants from '../../../src/constants';
import LearnerManager from '../../../src/learner-manager';
import Should from 'should';
import Sinon from 'sinon';

export default () => {

  describe('getMetricsByUri', () => {

    const maxRange = 31536000000;
    let server;

    before(() => {
      server = Sinon.fakeServer.create();
    });

    beforeEach(() => {
      server.resetHistory();
      server.respondImmediately = true;
      server.respondWith(TestConstants.defaultServerResponse);
      TestUtils.resetStateAndCache();
      TestUtils.setState(TestConstants.defaultState);
    });

    after(() => {
      server.restore();
      TestUtils.resetStateAndCache();
    });

    describe('Validate', () => {

      beforeEach(() => {
        server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
      });

      describe('metricUri is required and must be a string', () => {
        const testFunction = parameter => {
          return LearnerManager.getMetricsByUri(parameter);
        };
        TestUtils.validatePromiseProperty(testFunction, 'string', true);
      }); //END metricUri is required and must be a string

      describe('minTimestamp must be an integer that is at least 0 if defined', () => {
        const testFunction = parameter => {
          return LearnerManager.getMetricsByUri('metricUri', parameter);
        };
        TestUtils.validatePromiseProperty(testFunction, 'number', false, [0, 1, 1000000000], [-1, 1.5]);
      }); //END minTimestamp must be an integer that is at least 0 if defined

      describe('maxTimestamp must be a positive integer if defined', () => {
        const testFunction = parameter => {
          return LearnerManager.getMetricsByUri('metricUri', null, parameter);
        };
        TestUtils.validatePromiseProperty(testFunction, 'number', false, [1, 1000000000], [-1, 0, 1.5]);
      }); //END maxTimestamp must be a positive integer if defined

      describe('maxTimestamp must be greater than minTimestamp, but within ' + maxRange, () => {
        const testFunction = parameter => {
          return LearnerManager.getMetricsByUri('metricUri', 1000, parameter);
        };
        TestUtils.validatePromiseProperty(testFunction, 'number', false, [1001, 1000 + maxRange], [999, 1000, 1001 + maxRange]);
      }); //END maxTimestamp must be greater than minTimestamp if both defined

    }); //END Validate

    it('Correct API request sent', () => {
      const learnerId = 100;
      TestUtils.setState({learnerId});
      server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
      return Should(LearnerManager.getMetricsByUri('metricUri', 1000, 2000)).resolved().then(response => {
        Should(server.requests).length(1);
        const request = server.requests[0];
        Should(request.method).equal('POST');
        const parsed = JSON.parse(request.requestBody);
        Should(parsed.learnerId).equal(learnerId);
        Should(parsed.items).deepEqual([{name: 'metricUri', start: 1000, end: 2000}]);
        Should(response).equal('ok');
      });
    }); //END Correct API request sent

    it('Response handled correctly', () => {
      const learnerId = 100;
      TestUtils.setState({learnerId});
      server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
      return Should(LearnerManager.getMetricsByUri('metricUri')).resolved().then(result => {
        Should(result).deepEqual('ok');
      });
    }); //END Response handled correctly

    it('API error results in promise rejection', () => {
      const learnerId = 100;
      TestUtils.setState({learnerId});
      server.respondWith([500, {}, '']);
      return Should(LearnerManager.getMetricsByUri('metricUri')).rejected();
    }); //END API error results in promise rejection

    it('No learner returns undefined with no server request', () => {
      return Should(LearnerManager.getMetricsByUri('metricUri')).resolved().then(result => {
        Should(server.requests).length(0);
        Should(result).equal(undefined);
      });
    }); //END No learner returns undefined with no server request

    describe('Autogenerated Range', () => {

      it('No timestamps provided defaults to 364 days ago to 1 day in the future', () => {
        TestUtils.setState({learnerId: 100});
        server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
        return Should(LearnerManager.getMetricsByUri('metricUri')).resolved().then(response => {
          Should(server.requests).length(1);
          const parsed = JSON.parse(server.requests[0].requestBody);
          Should(parsed.items[0].end - parsed.items[0].start).equal(maxRange);
          Should(parsed.items[0].end).greaterThan(Date.now());
          Should(parsed.items[0].end).lessThanOrEqual(Date.now() + 86400000);
        });
      });

      it('No minTimestamp provided defaults to 365 days prior to maxTimestamp', () => {
        TestUtils.setState({learnerId: 100});
        server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
        return Should(LearnerManager.getMetricsByUri('metricUri', undefined, maxRange + 1000)).resolved().then(response => {
          Should(server.requests).length(1);
          const parsed = JSON.parse(server.requests[0].requestBody);
          Should(parsed.items[0].start).equal(1000);
          Should(parsed.items[0].end).equal(maxRange + 1000);
        });
      });

      it('minTimestamp will not got below 0', () => {
        TestUtils.setState({learnerId: 100});
        server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
        return Should(LearnerManager.getMetricsByUri('metricUri', undefined, maxRange - 1000)).resolved().then(response => {
          Should(server.requests).length(1);
          const parsed = JSON.parse(server.requests[0].requestBody);
          Should(parsed.items[0].start).equal(0);
          Should(parsed.items[0].end).equal(maxRange - 1000);
        });
      });

      it('No maxTimestamp provided defaults to 365 days after minTimestamp', () => {
        TestUtils.setState({learnerId: 100});
        server.respondWith([200, {'Content-Type': 'application/json'}, '"ok"']);
        return Should(LearnerManager.getMetricsByUri('metricUri', 1000)).resolved().then(response => {
          Should(server.requests).length(1);
          const parsed = JSON.parse(server.requests[0].requestBody);
          Should(parsed.items[0].start).equal(1000);
          Should(parsed.items[0].end).equal(maxRange + 1000);
        });
      });

    }); //END Autogenerated Range

  }); //END getMetricsByUri

}; //END export
